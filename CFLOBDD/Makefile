# Project Name (executable)
# PROJECT = cflobdd
# Detect the operating system
ifeq ($(OS),Windows_NT)
    # Windows (MinGW)
    PROJECT      = cflobdd.exe
else
    # Linux/Unix-like
    PROJECT      = cflobdd
endif

# Compiler
# CC = g++-11
CC = g++

# Run Options       
COMMANDLINE_OPTIONS = #/dev/ttyS0

# Compiler options during compilation
# -MMD: generate .d dependency files as a side effect of compilation
# -MP:  add phony targets for headers so deleting a header doesn't break make
COMPILE_OPTIONS = -g -O3 -std=c++2a -w -DCFLOBDD_C_EXPORTS -MMD -MP
ifdef NUM_BITS
COMPILE_OPTIONS += -DNUM_BITS=$(NUM_BITS)
endif
ifdef WCFLOBDD_SUPPORTED
COMPILE_OPTIONS += -DWCFLOBDD_SUPPORTED
endif
# -ansi -pedantic -Wall 

#Header include directories
HEADERS = -I. -I../../boost_1_81_0/ -I.Solver/uwr/bit_vector/ -I.Solver/uwr/assert/ -I.Solver/uwr/matrix/ -I.Solver/uwr/parsing/
#Libraries for linking
LIBS =

# Subdirs to search for additional source files
ifdef WCFLOBDD_SUPPORTED
SOURCE_FILES += $(shell ls *.cpp)
else
# Exclude weighted CFLOBDD sources (weighted_*.cpp and w*.cpp)
ALL_CPP := $(shell ls *.cpp)
SOURCE_FILES += $(filter-out weighted_%.cpp,$(filter-out w%.cpp,$(ALL_CPP)))
endif
SOURCE_FILES += $(shell ls Solver/uwr/bit_vector/*.cpp)
SOURCE_FILES += $(shell ls Solver/uwr/parsing/*.cpp)
# SOURCE_FILES += $(shell find . -maxdepth 1 -mindepth 1 -name \*.cpp -a -not -name main.cpp)

# Create an object file of every cpp file
OBJECTS = $(patsubst %.cpp, %.o, $(SOURCE_FILES))

# Dependencies
DEPENDENCIES = $(patsubst %.cpp, %.d, $(SOURCE_FILES))

# Make $(PROJECT) the default target
all: $(PROJECT)
#$(DEPENDENCIES) -shared -dynamiclib 
$(PROJECT): $(OBJECTS)
	$(CC) -o $(PROJECT) $(OBJECTS) $(LIBS)

# Include dependencies (generated by -MMD during compilation)
# The dash prefix silently ignores missing .d files on first build.
-include $(DEPENDENCIES)

# Compile every cpp file to an object
# %.cpp 
%.o: %.cpp
	$(CC) -c $(COMPILE_OPTIONS) -o $@ $< $(HEADERS)

# Build & Run Project
run: $(PROJECT)
	./$(PROJECT) $(COMMANDLINE_OPTIONS)

# Clean & Debug
.PHONY: makefile-debug
makefile-debug:

.PHONY: clean
clean:
	rm -f $(PROJECT) $(OBJECTS)

.PHONY: depclean
depclean:
	rm -f $(DEPENDENCIES)

clean-all: clean depclean

# Per-width build targets for CRT multiplication
# These objects depend on NUM_BITS or WCFLOBDD_SUPPORTED;
# delete them to force recompilation when switching widths or build modes.
NUM_BITS_OBJS = multiplication_crt.o tests_cfl.o cflobdd_c.o return_map_specializations.o

.PHONY: cflobdd32 cflobdd64 cflobdd128 cflobdd256 cflobdd512 cflobdd1024 cflobdd2048 cflobdd4096

cflobdd32:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=32 PROJECT=cflobdd32.exe

cflobdd64:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=64 PROJECT=cflobdd64.exe

cflobdd128:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=128 PROJECT=cflobdd128.exe

cflobdd256:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=256 PROJECT=cflobdd256.exe

cflobdd512:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=512 PROJECT=cflobdd512.exe

cflobdd1024:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=1024 PROJECT=cflobdd1024.exe

cflobdd2048:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=2048 PROJECT=cflobdd2048.exe

cflobdd4096:
	rm -f $(NUM_BITS_OBJS)
	$(MAKE) NUM_BITS=4096 PROJECT=cflobdd4096.exe

MULT = cflobdd32.exe
spec-all-test:
	./$(MULT) spec-all
	./$(MULT) spec-all
	./$(MULT) spec-all
	./$(MULT) spec-all

shiftadd-all-test:
	./$(MULT) shiftadd-all
	./$(MULT) shiftadd-all
	./$(MULT) shiftadd-all
	./$(MULT) shiftadd-all

karatsuba-all-test:
	./$(MULT) karatsuba-all
	./$(MULT) karatsuba-all
	./$(MULT) karatsuba-all
	./$(MULT) karatsuba-all

mult-tests:
	make spec-all-test MULT=cflobdd32.exe
	make shiftadd-all-test MULT=cflobdd32.exe
	make karatsuba-all-test MULT=cflobdd32.exe
	make spec-all-test MULT=cflobdd64.exe
	make shiftadd-all-test MULT=cflobdd64.exe
	make karatsuba-all-test MULT=cflobdd64.exe
	make spec-all-test MULT=cflobdd128.exe
	make shiftadd-all-test MULT=cflobdd128.exe
	make spec-all-test MULT=cflobdd256.exe
	make shiftadd-all-test MULT=cflobdd256.exe